### 散列表（待实现）

散列表本质是通过hash算法，将key对应到一个数组的下标，并在存储value，在不考虑散列冲突的情况下，查找/删除/存储的时间复杂度都为O(1)

### 散列表 + 链表

为了解决散列冲突，将同一个key下的values以链表形式存储，但数据分布均匀，数据范围和散列容量的比例m/n特别大的时候，查找/删除/存储的时间复杂度都近似为O(1)

### 散列表 + 双向链表 实现LRU（最新使用优先）缓存淘汰算法

散列表的优势在于其O(1)的查找能力，如果只通过链表实现LRU算法其查找复杂度为O(n)，但是将散列和链表的结合多数情况可以将查找的时间复杂度将为O(1)