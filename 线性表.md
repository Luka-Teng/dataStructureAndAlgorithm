## 顺序存储结构

类似于数组结构，数据的地址单元是相连着的，查询的复杂度度为O(1)，插入删除的平均复杂度为O(n)

具体代码就不展开讲了，没意义。

## 链式存储结构（链表）

### 单链表

描述： 每个节点只包含一个指针域（指向下一个节点），一般第一个节点的存储位置称为头指针，最后一个节点的地址指向null

头指针：指向头结点的指针，是必要元素，如果没有头结点指向null

头结点： 第一个节点，非必要元素，一般头结点后面的元素才是真正要存储的元素

---
#### P1: 
```
  type ElemType = {...}

  class Node {
    // 数据域, 存储的类型
    data: ElemType

    // 指针域，指向下一个的指针
    next: Node
  }

  class NodeList {
    // 头指针
    firstNode: Node = null

    // 初始化链表
    init (node: Node) {
      this.firstNode = node
    }

    // 获取某一个节点
    getNode (i: number): Node | never {
      if (i < 0) {
        throw new Error('其实位置最小为0')
      }

      let n = this.firstNode
      let j = 0

      while (n && j < i) {
        n = n.next
        j++
      }

      if (!n) {
        return null
      }

      return n
    }

    // 插入某一个节点
    insertNode (i: number, node: Node): void | never {
      const preNode = this.getNode(i)

      if (!preNode) {
        throw new Error('不存在该节点')
      }

      node.next = preNode.next
      preNode.next = node
    }

    // 删除某个节点
    removeNode (i: number): void | never {
      if (i === 0) {
        this.firstNode = this.firstNode && this.firstNode.next
        return
      }

      const preNode = this.getNode(i - 1)

      if (!preNode || !preNode.next) {
        throw new Error('不存在可以删除的节点')
      }

      preNode.next = preNode.next.next
    }
  }
```

时间复杂度： 对于查询，插入，删除都是O(n)。

劣势：相对于数组查询更加耗时

优势：
1. 删除，插入效率高，虽然都是O(n)但是查询比赋值效率高

2. 如果已知某个位置i的node时候，插入效率为O(1)，因此对于频繁删除，插入效率更高
    
---